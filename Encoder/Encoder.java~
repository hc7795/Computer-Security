import java.util.*;
import java.io.*;


abstract class HuffmanTree implements Comparable<HuffmanTree> {
    public final int frequency; // the frequency of this tree
    public HuffmanTree(int freq) { frequency = freq; }
    
    // compares on the frequency
    public int compareTo(HuffmanTree tree) {
        return frequency - tree.frequency;
    }
}

class HuffmanLeaf extends HuffmanTree {
    public final char value; // the character this leaf represents
    
    public HuffmanLeaf(int freq, char val) {
        super(freq); //super calls a constructor of the superclass, which is HuffmanTree.
        value = val;
    }
}

class HuffmanNode extends HuffmanTree {
    public final HuffmanTree left, right; // subtrees
    
    public HuffmanNode(HuffmanTree l, HuffmanTree r) {
        super(l.frequency + r.frequency);
        left = l;
        right = r;
    }
}

public class Encoder{
	
	
	public static void main(String args[]) throws IOException{
		File input = new File(args[0]);
		Scanner reader = new Scanner(input);
		char[] alph = {' ', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'};
		int[] charFreqs = new int[256];
		int index = 1;
		while(reader.hasNextLine()) {
			String frequency = reader.nextLine();
			for(int i = 0; i < Integer.parseInt(frequency); i++) {
				++charFreqs[alph[index]];
			}
			++index;
		}
		
		HuffmanTree tree = buildTree(charFreqs);
		
		System.out.println("SYMBOL\tWEIGHT\tHUFFMAN CODE");
		printCodes(tree, new StringBuffer());
		
	}
	
	public static HuffmanTree buildTree(int[] charFreqs) {
	    PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();
	    // initially, we have a forest of leaves
	    // one for each non-empty character
	    for (int i = 0; i < charFreqs.length; i++)
		if (charFreqs[i] > 0) {
		    System.out.println("charFreqs[i] = " + charFreqs[i]);
		    trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));
		}
	    assert trees.size() > 0;
	    // loop until there is only one tree left
	    while (trees.size() > 1) {
		System.out.println("trees.size() = " + trees.size());
		// two trees with least frequency
		System.out.println("***");
		HuffmanTree a = trees.poll();
		HuffmanTree b = trees.poll();
		//HuffmanLeaf la = (HuffmanLeaf)a;
		//HuffmanLeaf lb = (HuffmanLeaf)b;
		//System.out.println("a.value = " + la.value);
		//System.out.println("b.value = " + lb.value);
		//System.out.println("a.frequency = " + a.frequency);
		//System.out.println("b.frequency = " + b.frequency);
		// put into new node and re-insert into queue
		trees.offer(new HuffmanNode(a, b));
	    }
	    return trees.poll();
	}

	public static void printCodes(HuffmanTree tree, StringBuffer prefix) {
	    assert tree != null;
	    if (tree instanceof HuffmanLeaf) {
		HuffmanLeaf leaf = (HuffmanLeaf)tree;
		
		// print out character, frequency, and code for this leaf (which is just the prefix)
		System.out.println(leaf.value + "\t" + leaf.frequency + "\t" + prefix);

	    } else if (tree instanceof HuffmanNode) {
		HuffmanNode node = (HuffmanNode)tree;
		
		// traverse left
		prefix.append('0');
		printCodes(node.left, prefix);
		prefix.deleteCharAt(prefix.length()-1);
		
		// traverse right
		prefix.append('1');
		printCodes(node.right, prefix);
		prefix.deleteCharAt(prefix.length()-1);
	    }
	}
}
